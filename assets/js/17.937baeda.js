(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{240:function(n,t,e){"use strict";e.r(t);var i=e(0),o=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"content"},[e("blockquote",[e("p",[n._v("1 调用堆栈")])]),n._v(" "),e("ul",[e("li",[n._v("理解javascript中执行上下文和执行栈")]),n._v(" "),e("li",[n._v("执行上下文和变量对象")]),n._v(" "),e("li",[n._v("内存空间详解")]),n._v(" "),e("li",[n._v("内存机制")]),n._v(" "),e("li",[n._v("如何避免内存泄漏")])]),n._v(" "),e("blockquote",[e("p",[n._v("2 作用域闭包\n3 this全面解析\n4 深浅拷贝原理\n5 原型Prototype\n6 高阶函数\n7 事件机制\n8 Event Loop原理\n9 Promise原理\nAsync/Await原理\n防抖/节流原理\n模块化详解\nES6重难点\n计算机网络概述\n浏览器渲染原理\nwebpack配置\nwebpack原理\n前端监控\n跨域和安全\n性能优化\nVirtualDom原理\nDiff算法\nMVVM双向绑定\nVuex原理\nRedux原理\n路由原理\nVueRouter源码解析\nReactRouter源码解析")])])])}],!1,null,null,null);o.options.__file="README.md";t.default=o.exports}}]);